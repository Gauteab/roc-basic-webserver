// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]


#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct InternalCommand {
    pub args: roc_std::RocList<roc_std::RocStr>,
    pub envs: roc_std::RocList<roc_std::RocStr>,
    pub program: roc_std::RocStr,
    pub clearEnvs: bool,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_InternalCommandErr {
    ExitCode = 0,
    IOError = 1,
    KilledBySignal = 2,
}

impl core::fmt::Debug for discriminant_InternalCommandErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ExitCode => f.write_str("discriminant_InternalCommandErr::ExitCode"),
            Self::IOError => f.write_str("discriminant_InternalCommandErr::IOError"),
            Self::KilledBySignal => f.write_str("discriminant_InternalCommandErr::KilledBySignal"),
        }
    }
}

#[repr(C, align(8))]
pub union union_InternalCommandErr {
    ExitCode: i32,
    IOError: core::mem::ManuallyDrop<roc_std::RocStr>,
    KilledBySignal: (),
}

const _SIZE_CHECK_union_InternalCommandErr: () = assert!(core::mem::size_of::<union_InternalCommandErr>() == 24);
const _ALIGN_CHECK_union_InternalCommandErr: () = assert!(core::mem::align_of::<union_InternalCommandErr>() == 8);

const _SIZE_CHECK_InternalCommandErr: () = assert!(core::mem::size_of::<InternalCommandErr>() == 32);
const _ALIGN_CHECK_InternalCommandErr: () = assert!(core::mem::align_of::<InternalCommandErr>() == 8);

impl InternalCommandErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_InternalCommandErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_InternalCommandErr>(*bytes.as_ptr().add(24))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_InternalCommandErr) {
        let discriminant_ptr: *mut discriminant_InternalCommandErr = (self as *mut InternalCommandErr).cast();

        unsafe {
            *(discriminant_ptr.add(24)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct InternalCommandErr {
    payload: union_InternalCommandErr,
    discriminant: discriminant_InternalCommandErr,
}

impl Clone for InternalCommandErr {
    fn clone(&self) -> Self {
        use discriminant_InternalCommandErr::*;

        let payload = unsafe {
            match self.discriminant {
                ExitCode => union_InternalCommandErr {
                    ExitCode: self.payload.ExitCode.clone(),
                },
                IOError => union_InternalCommandErr {
                    IOError: self.payload.IOError.clone(),
                },
                KilledBySignal => union_InternalCommandErr {
                    KilledBySignal: self.payload.KilledBySignal.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for InternalCommandErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_InternalCommandErr::*;

        unsafe {
            match self.discriminant {
                ExitCode => {
                    let field: &i32 = &self.payload.ExitCode;
                    f.debug_tuple("InternalCommandErr::ExitCode").field(field).finish()
                },
                IOError => {
                    let field: &roc_std::RocStr = &self.payload.IOError;
                    f.debug_tuple("InternalCommandErr::IOError").field(field).finish()
                },
                KilledBySignal => {
                    let field: &() = &self.payload.KilledBySignal;
                    f.debug_tuple("InternalCommandErr::KilledBySignal").field(field).finish()
                },
            }
        }
    }
}

impl Eq for InternalCommandErr {}

impl PartialEq for InternalCommandErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_InternalCommandErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                ExitCode => self.payload.ExitCode == other.payload.ExitCode,
                IOError => self.payload.IOError == other.payload.IOError,
                KilledBySignal => self.payload.KilledBySignal == other.payload.KilledBySignal,
            }
        }
    }
}

impl Ord for InternalCommandErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for InternalCommandErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_InternalCommandErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    ExitCode => self.payload.ExitCode.partial_cmp(&other.payload.ExitCode),
                    IOError => self.payload.IOError.partial_cmp(&other.payload.IOError),
                    KilledBySignal => self.payload.KilledBySignal.partial_cmp(&other.payload.KilledBySignal),
                }
            },
        }
    }
}

impl core::hash::Hash for InternalCommandErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_InternalCommandErr::*;

        unsafe {
            match self.discriminant {
                ExitCode => self.payload.ExitCode.hash(state),
                IOError => self.payload.IOError.hash(state),
                KilledBySignal => self.payload.KilledBySignal.hash(state),
            }
        }
    }
}

impl InternalCommandErr {

    pub fn unwrap_ExitCode(mut self) -> i32 {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::ExitCode);
        unsafe { self.payload.ExitCode }
    }

    pub fn is_ExitCode(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalCommandErr::ExitCode)
    }

    pub fn unwrap_IOError(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::IOError);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.IOError) }
    }

    pub fn is_IOError(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalCommandErr::IOError)
    }

    pub fn is_KilledBySignal(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalCommandErr::KilledBySignal)
    }
}



impl InternalCommandErr {

    pub fn ExitCode(payload: i32) -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::ExitCode,
            payload: union_InternalCommandErr {
                ExitCode: payload,
            }
        }
    }

    pub fn IOError(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::IOError,
            payload: union_InternalCommandErr {
                IOError: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn KilledBySignal() -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::KilledBySignal,
            payload: union_InternalCommandErr {
                KilledBySignal: (),
            }
        }
    }
}

impl Drop for InternalCommandErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_InternalCommandErr::ExitCode => {}
            discriminant_InternalCommandErr::IOError => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.IOError) },
            discriminant_InternalCommandErr::KilledBySignal => {}
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct InternalOutput {
    pub status: roc_std::RocResult<(), InternalCommandErr>,
    pub stderr: roc_std::RocList<u8>,
    pub stdout: roc_std::RocList<u8>,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_CommandTypes {
    A = 0,
    B = 1,
    C = 2,
}

impl core::fmt::Debug for discriminant_CommandTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::A => f.write_str("discriminant_CommandTypes::A"),
            Self::B => f.write_str("discriminant_CommandTypes::B"),
            Self::C => f.write_str("discriminant_CommandTypes::C"),
        }
    }
}

#[repr(C, align(8))]
pub union union_CommandTypes {
    A: core::mem::ManuallyDrop<InternalCommand>,
    B: core::mem::ManuallyDrop<InternalOutput>,
    C: core::mem::ManuallyDrop<InternalCommandErr>,
}

const _SIZE_CHECK_union_CommandTypes: () = assert!(core::mem::size_of::<union_CommandTypes>() == 88);
const _ALIGN_CHECK_union_CommandTypes: () = assert!(core::mem::align_of::<union_CommandTypes>() == 8);

const _SIZE_CHECK_CommandTypes: () = assert!(core::mem::size_of::<CommandTypes>() == 96);
const _ALIGN_CHECK_CommandTypes: () = assert!(core::mem::align_of::<CommandTypes>() == 8);

impl CommandTypes {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_CommandTypes {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_CommandTypes>(*bytes.as_ptr().add(88))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_CommandTypes) {
        let discriminant_ptr: *mut discriminant_CommandTypes = (self as *mut CommandTypes).cast();

        unsafe {
            *(discriminant_ptr.add(88)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct CommandTypes {
    payload: union_CommandTypes,
    discriminant: discriminant_CommandTypes,
}

impl Clone for CommandTypes {
    fn clone(&self) -> Self {
        use discriminant_CommandTypes::*;

        let payload = unsafe {
            match self.discriminant {
                A => union_CommandTypes {
                    A: self.payload.A.clone(),
                },
                B => union_CommandTypes {
                    B: self.payload.B.clone(),
                },
                C => union_CommandTypes {
                    C: self.payload.C.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for CommandTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_CommandTypes::*;

        unsafe {
            match self.discriminant {
                A => {
                    let field: &InternalCommand = &self.payload.A;
                    f.debug_tuple("CommandTypes::A").field(field).finish()
                },
                B => {
                    let field: &InternalOutput = &self.payload.B;
                    f.debug_tuple("CommandTypes::B").field(field).finish()
                },
                C => {
                    let field: &InternalCommandErr = &self.payload.C;
                    f.debug_tuple("CommandTypes::C").field(field).finish()
                },
            }
        }
    }
}

// impl Eq for CommandTypes {}

// impl PartialEq for CommandTypes {
//     fn eq(&self, other: &Self) -> bool {
//         use discriminant_CommandTypes::*;

//         if self.discriminant != other.discriminant {
//             return false;
//         }

//         unsafe {
//             match self.discriminant {
//                 A => self.payload.A == other.payload.A,
//                 B => self.payload.B == other.payload.B,
//                 C => self.payload.C == other.payload.C,
//             }
//         }
//     }
// }

// impl Ord for CommandTypes {
//     fn cmp(&self, other: &Self) -> std::cmp::Ordering {
//         self.partial_cmp(other).unwrap()
//     }
// }

// impl PartialOrd for CommandTypes {
//     fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
//         use discriminant_CommandTypes::*;

//         use std::cmp::Ordering::*;

//         match self.discriminant.cmp(&other.discriminant) {
//             Less => Option::Some(Less),
//             Greater => Option::Some(Greater),
//             Equal => unsafe {
//                 match self.discriminant {
//                     A => self.payload.A.partial_cmp(&other.payload.A),
//                     B => self.payload.B.partial_cmp(&other.payload.B),
//                     C => self.payload.C.partial_cmp(&other.payload.C),
//                 }
//             },
//         }
//     }
// }

// impl core::hash::Hash for CommandTypes {
//     fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
//         use discriminant_CommandTypes::*;

//         unsafe {
//             match self.discriminant {
//                 A => self.payload.A.hash(state),
//                 B => self.payload.B.hash(state),
//                 C => self.payload.C.hash(state),
//             }
//         }
//     }
// }

// impl CommandTypes {

//     pub fn unwrap_A(mut self) -> InternalCommand {
//         debug_assert_eq!(self.discriminant, discriminant_CommandTypes::A);
//         unsafe { core::mem::ManuallyDrop::take(&mut self.payload.A) }
//     }

//     pub fn is_A(&self) -> bool {
//         matches!(self.discriminant, discriminant_CommandTypes::A)
//     }

//     pub fn unwrap_B(mut self) -> InternalOutput {
//         debug_assert_eq!(self.discriminant, discriminant_CommandTypes::B);
//         unsafe { core::mem::ManuallyDrop::take(&mut self.payload.B) }
//     }

//     pub fn is_B(&self) -> bool {
//         matches!(self.discriminant, discriminant_CommandTypes::B)
//     }

//     pub fn unwrap_C(mut self) -> InternalCommandErr {
//         debug_assert_eq!(self.discriminant, discriminant_CommandTypes::C);
//         unsafe { core::mem::ManuallyDrop::take(&mut self.payload.C) }
//     }

//     pub fn is_C(&self) -> bool {
//         matches!(self.discriminant, discriminant_CommandTypes::C)
//     }
// }



// impl CommandTypes {

//     pub fn A(payload: InternalCommand) -> Self {
//         Self {
//             discriminant: discriminant_CommandTypes::A,
//             payload: union_CommandTypes {
//                 A: core::mem::ManuallyDrop::new(payload),
//             }
//         }
//     }

//     pub fn B(payload: InternalOutput) -> Self {
//         Self {
//             discriminant: discriminant_CommandTypes::B,
//             payload: union_CommandTypes {
//                 B: core::mem::ManuallyDrop::new(payload),
//             }
//         }
//     }

//     pub fn C(payload: InternalCommandErr) -> Self {
//         Self {
//             discriminant: discriminant_CommandTypes::C,
//             payload: union_CommandTypes {
//                 C: core::mem::ManuallyDrop::new(payload),
//             }
//         }
//     }
// }

// impl Drop for CommandTypes {
//     fn drop(&mut self) {
//         // Drop the payloads
//         match self.discriminant() {
//             discriminant_CommandTypes::A => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.A) },
//             discriminant_CommandTypes::B => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.B) },
//             discriminant_CommandTypes::C => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.C) },
//         }
//     }
// }



// pub fn mainForHost() -> CommandTypes {
//     extern "C" {
//         fn roc__mainForHost_1_exposed_generic(_: *mut CommandTypes);
//     }

//     let mut ret = core::mem::MaybeUninit::uninit();

//     unsafe {
//         roc__mainForHost_1_exposed_generic(ret.as_mut_ptr(), );

//         ret.assume_init()
//     }
// }