// ⚠️ GENERATED CODE ⚠️ - this entire file was generated by the `roc glue` CLI command

#![allow(unused_unsafe)]
#![allow(dead_code)]
#![allow(unused_mut)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(clippy::undocumented_unsafe_blocks)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::unused_unit)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::let_and_return)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::redundant_static_lifetimes)]
#![allow(clippy::needless_borrow)]
#![allow(clippy::clone_on_copy)]


#[derive(Clone, Default, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct InternalCommand {
    pub args: roc_std::RocList<roc_std::RocStr>,
    pub envs: roc_std::RocList<roc_std::RocStr>,
    pub program: roc_std::RocStr,
    pub clearEnvs: bool,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_InternalCommandErr {
    ExitCode = 0,
    IOError = 1,
    KilledBySignal = 2,
}

impl core::fmt::Debug for discriminant_InternalCommandErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::ExitCode => f.write_str("discriminant_InternalCommandErr::ExitCode"),
            Self::IOError => f.write_str("discriminant_InternalCommandErr::IOError"),
            Self::KilledBySignal => f.write_str("discriminant_InternalCommandErr::KilledBySignal"),
        }
    }
}

#[repr(C, align(4))]
pub union union_InternalCommandErr {
    ExitCode: i32,
    IOError: core::mem::ManuallyDrop<roc_std::RocStr>,
    KilledBySignal: (),
}

const _SIZE_CHECK_union_InternalCommandErr: () = assert!(core::mem::size_of::<union_InternalCommandErr>() == 12);
const _ALIGN_CHECK_union_InternalCommandErr: () = assert!(core::mem::align_of::<union_InternalCommandErr>() == 4);

const _SIZE_CHECK_InternalCommandErr: () = assert!(core::mem::size_of::<InternalCommandErr>() == 16);
const _ALIGN_CHECK_InternalCommandErr: () = assert!(core::mem::align_of::<InternalCommandErr>() == 4);

impl InternalCommandErr {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_InternalCommandErr {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_InternalCommandErr>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_InternalCommandErr) {
        let discriminant_ptr: *mut discriminant_InternalCommandErr = (self as *mut InternalCommandErr).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct InternalCommandErr {
    payload: union_InternalCommandErr,
    discriminant: discriminant_InternalCommandErr,
}

impl Clone for InternalCommandErr {
    fn clone(&self) -> Self {
        use discriminant_InternalCommandErr::*;

        let payload = unsafe {
            match self.discriminant {
                ExitCode => union_InternalCommandErr {
                    ExitCode: self.payload.ExitCode.clone(),
                },
                IOError => union_InternalCommandErr {
                    IOError: self.payload.IOError.clone(),
                },
                KilledBySignal => union_InternalCommandErr {
                    KilledBySignal: self.payload.KilledBySignal.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for InternalCommandErr {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_InternalCommandErr::*;

        unsafe {
            match self.discriminant {
                ExitCode => {
                    let field: &i32 = &self.payload.ExitCode;
                    f.debug_tuple("InternalCommandErr::ExitCode").field(field).finish()
                },
                IOError => {
                    let field: &roc_std::RocStr = &self.payload.IOError;
                    f.debug_tuple("InternalCommandErr::IOError").field(field).finish()
                },
                KilledBySignal => {
                    let field: &() = &self.payload.KilledBySignal;
                    f.debug_tuple("InternalCommandErr::KilledBySignal").field(field).finish()
                },
            }
        }
    }
}

impl Eq for InternalCommandErr {}

impl PartialEq for InternalCommandErr {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_InternalCommandErr::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                ExitCode => self.payload.ExitCode == other.payload.ExitCode,
                IOError => self.payload.IOError == other.payload.IOError,
                KilledBySignal => self.payload.KilledBySignal == other.payload.KilledBySignal,
            }
        }
    }
}

impl Ord for InternalCommandErr {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for InternalCommandErr {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_InternalCommandErr::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    ExitCode => self.payload.ExitCode.partial_cmp(&other.payload.ExitCode),
                    IOError => self.payload.IOError.partial_cmp(&other.payload.IOError),
                    KilledBySignal => self.payload.KilledBySignal.partial_cmp(&other.payload.KilledBySignal),
                }
            },
        }
    }
}

impl core::hash::Hash for InternalCommandErr {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_InternalCommandErr::*;

        unsafe {
            match self.discriminant {
                ExitCode => self.payload.ExitCode.hash(state),
                IOError => self.payload.IOError.hash(state),
                KilledBySignal => self.payload.KilledBySignal.hash(state),
            }
        }
    }
}

impl InternalCommandErr {

    pub fn unwrap_ExitCode(mut self) -> i32 {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::ExitCode);
        unsafe { self.payload.ExitCode }
    }

    pub fn is_ExitCode(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalCommandErr::ExitCode)
    }

    pub fn unwrap_IOError(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalCommandErr::IOError);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.IOError) }
    }

    pub fn is_IOError(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalCommandErr::IOError)
    }

    pub fn is_KilledBySignal(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalCommandErr::KilledBySignal)
    }
}



impl InternalCommandErr {

    pub fn ExitCode(payload: i32) -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::ExitCode,
            payload: union_InternalCommandErr {
                ExitCode: payload,
            }
        }
    }

    pub fn IOError(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::IOError,
            payload: union_InternalCommandErr {
                IOError: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn KilledBySignal() -> Self {
        Self {
            discriminant: discriminant_InternalCommandErr::KilledBySignal,
            payload: union_InternalCommandErr {
                KilledBySignal: (),
            }
        }
    }
}

impl Drop for InternalCommandErr {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_InternalCommandErr::ExitCode => {}
            discriminant_InternalCommandErr::IOError => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.IOError) },
            discriminant_InternalCommandErr::KilledBySignal => {}
        }
    }
}

#[derive(Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(C)]
pub struct InternalOutput {
    pub status: roc_std::RocResult<(), InternalCommandErr>,
    pub stderr: roc_std::RocList<u8>,
    pub stdout: roc_std::RocList<u8>,
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_InternalError {
    EOF = 0,
    IOError = 1,
}

impl core::fmt::Debug for discriminant_InternalError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::EOF => f.write_str("discriminant_InternalError::EOF"),
            Self::IOError => f.write_str("discriminant_InternalError::IOError"),
        }
    }
}

#[repr(C, align(4))]
pub union union_InternalError {
    EOF: (),
    IOError: core::mem::ManuallyDrop<roc_std::RocStr>,
}

const _SIZE_CHECK_union_InternalError: () = assert!(core::mem::size_of::<union_InternalError>() == 12);
const _ALIGN_CHECK_union_InternalError: () = assert!(core::mem::align_of::<union_InternalError>() == 4);

const _SIZE_CHECK_InternalError: () = assert!(core::mem::size_of::<InternalError>() == 16);
const _ALIGN_CHECK_InternalError: () = assert!(core::mem::align_of::<InternalError>() == 4);

impl InternalError {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_InternalError {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_InternalError>(*bytes.as_ptr().add(12))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_InternalError) {
        let discriminant_ptr: *mut discriminant_InternalError = (self as *mut InternalError).cast();

        unsafe {
            *(discriminant_ptr.add(12)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct InternalError {
    payload: union_InternalError,
    discriminant: discriminant_InternalError,
}

impl Clone for InternalError {
    fn clone(&self) -> Self {
        use discriminant_InternalError::*;

        let payload = unsafe {
            match self.discriminant {
                EOF => union_InternalError {
                    EOF: self.payload.EOF.clone(),
                },
                IOError => union_InternalError {
                    IOError: self.payload.IOError.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for InternalError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_InternalError::*;

        unsafe {
            match self.discriminant {
                EOF => {
                    let field: &() = &self.payload.EOF;
                    f.debug_tuple("InternalError::EOF").field(field).finish()
                },
                IOError => {
                    let field: &roc_std::RocStr = &self.payload.IOError;
                    f.debug_tuple("InternalError::IOError").field(field).finish()
                },
            }
        }
    }
}

impl Eq for InternalError {}

impl PartialEq for InternalError {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_InternalError::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                EOF => self.payload.EOF == other.payload.EOF,
                IOError => self.payload.IOError == other.payload.IOError,
            }
        }
    }
}

impl Ord for InternalError {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for InternalError {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_InternalError::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    EOF => self.payload.EOF.partial_cmp(&other.payload.EOF),
                    IOError => self.payload.IOError.partial_cmp(&other.payload.IOError),
                }
            },
        }
    }
}

impl core::hash::Hash for InternalError {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_InternalError::*;

        unsafe {
            match self.discriminant {
                EOF => self.payload.EOF.hash(state),
                IOError => self.payload.IOError.hash(state),
            }
        }
    }
}

impl InternalError {

    pub fn is_EOF(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalError::EOF)
    }

    pub fn unwrap_IOError(mut self) -> roc_std::RocStr {
        debug_assert_eq!(self.discriminant, discriminant_InternalError::IOError);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.IOError) }
    }

    pub fn is_IOError(&self) -> bool {
        matches!(self.discriminant, discriminant_InternalError::IOError)
    }
}



impl InternalError {

    pub fn EOF() -> Self {
        Self {
            discriminant: discriminant_InternalError::EOF,
            payload: union_InternalError {
                EOF: (),
            }
        }
    }

    pub fn IOError(payload: roc_std::RocStr) -> Self {
        Self {
            discriminant: discriminant_InternalError::IOError,
            payload: union_InternalError {
                IOError: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for InternalError {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_InternalError::EOF => {}
            discriminant_InternalError::IOError => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.IOError) },
        }
    }
}

#[derive(Clone, Copy, PartialEq, PartialOrd, Eq, Ord, Hash, )]
#[repr(u8)]
pub enum discriminant_GlueTypes {
    A = 0,
    B = 1,
    C = 2,
    D = 3,
}

impl core::fmt::Debug for discriminant_GlueTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            Self::A => f.write_str("discriminant_GlueTypes::A"),
            Self::B => f.write_str("discriminant_GlueTypes::B"),
            Self::C => f.write_str("discriminant_GlueTypes::C"),
            Self::D => f.write_str("discriminant_GlueTypes::D"),
        }
    }
}

#[repr(C, align(4))]
pub union union_GlueTypes {
    A: core::mem::ManuallyDrop<InternalCommand>,
    B: core::mem::ManuallyDrop<InternalOutput>,
    C: core::mem::ManuallyDrop<InternalCommandErr>,
    D: core::mem::ManuallyDrop<InternalError>,
}

const _SIZE_CHECK_union_GlueTypes: () = assert!(core::mem::size_of::<union_GlueTypes>() == 44);
const _ALIGN_CHECK_union_GlueTypes: () = assert!(core::mem::align_of::<union_GlueTypes>() == 4);

const _SIZE_CHECK_GlueTypes: () = assert!(core::mem::size_of::<GlueTypes>() == 48);
const _ALIGN_CHECK_GlueTypes: () = assert!(core::mem::align_of::<GlueTypes>() == 4);

impl GlueTypes {
    /// Returns which variant this tag union holds. Note that this never includes a payload!
    pub fn discriminant(&self) -> discriminant_GlueTypes {
        unsafe {
            let bytes = core::mem::transmute::<&Self, &[u8; core::mem::size_of::<Self>()]>(self);

            core::mem::transmute::<u8, discriminant_GlueTypes>(*bytes.as_ptr().add(44))
        }
    }

    /// Internal helper
    fn set_discriminant(&mut self, discriminant: discriminant_GlueTypes) {
        let discriminant_ptr: *mut discriminant_GlueTypes = (self as *mut GlueTypes).cast();

        unsafe {
            *(discriminant_ptr.add(44)) = discriminant;
        }
    }
}

#[repr(C)]
pub struct GlueTypes {
    payload: union_GlueTypes,
    discriminant: discriminant_GlueTypes,
}

impl Clone for GlueTypes {
    fn clone(&self) -> Self {
        use discriminant_GlueTypes::*;

        let payload = unsafe {
            match self.discriminant {
                A => union_GlueTypes {
                    A: self.payload.A.clone(),
                },
                B => union_GlueTypes {
                    B: self.payload.B.clone(),
                },
                C => union_GlueTypes {
                    C: self.payload.C.clone(),
                },
                D => union_GlueTypes {
                    D: self.payload.D.clone(),
                },
            }
        };

        Self {
            discriminant: self.discriminant,
            payload,
        }
    }
}

impl core::fmt::Debug for GlueTypes {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        use discriminant_GlueTypes::*;

        unsafe {
            match self.discriminant {
                A => {
                    let field: &InternalCommand = &self.payload.A;
                    f.debug_tuple("GlueTypes::A").field(field).finish()
                },
                B => {
                    let field: &InternalOutput = &self.payload.B;
                    f.debug_tuple("GlueTypes::B").field(field).finish()
                },
                C => {
                    let field: &InternalCommandErr = &self.payload.C;
                    f.debug_tuple("GlueTypes::C").field(field).finish()
                },
                D => {
                    let field: &InternalError = &self.payload.D;
                    f.debug_tuple("GlueTypes::D").field(field).finish()
                },
            }
        }
    }
}

impl Eq for GlueTypes {}

impl PartialEq for GlueTypes {
    fn eq(&self, other: &Self) -> bool {
        use discriminant_GlueTypes::*;

        if self.discriminant != other.discriminant {
            return false;
        }

        unsafe {
            match self.discriminant {
                A => self.payload.A == other.payload.A,
                B => self.payload.B == other.payload.B,
                C => self.payload.C == other.payload.C,
                D => self.payload.D == other.payload.D,
            }
        }
    }
}

impl Ord for GlueTypes {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        self.partial_cmp(other).unwrap()
    }
}

impl PartialOrd for GlueTypes {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        use discriminant_GlueTypes::*;

        use std::cmp::Ordering::*;

        match self.discriminant.cmp(&other.discriminant) {
            Less => Option::Some(Less),
            Greater => Option::Some(Greater),
            Equal => unsafe {
                match self.discriminant {
                    A => self.payload.A.partial_cmp(&other.payload.A),
                    B => self.payload.B.partial_cmp(&other.payload.B),
                    C => self.payload.C.partial_cmp(&other.payload.C),
                    D => self.payload.D.partial_cmp(&other.payload.D),
                }
            },
        }
    }
}

impl core::hash::Hash for GlueTypes {
    fn hash<H: core::hash::Hasher>(&self, state: &mut H) {
        use discriminant_GlueTypes::*;

        unsafe {
            match self.discriminant {
                A => self.payload.A.hash(state),
                B => self.payload.B.hash(state),
                C => self.payload.C.hash(state),
                D => self.payload.D.hash(state),
            }
        }
    }
}

impl GlueTypes {

    pub fn unwrap_A(mut self) -> InternalCommand {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::A);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.A) }
    }

    pub fn is_A(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::A)
    }

    pub fn unwrap_B(mut self) -> InternalOutput {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::B);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.B) }
    }

    pub fn is_B(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::B)
    }

    pub fn unwrap_C(mut self) -> InternalCommandErr {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::C);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.C) }
    }

    pub fn is_C(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::C)
    }

    pub fn unwrap_D(mut self) -> InternalError {
        debug_assert_eq!(self.discriminant, discriminant_GlueTypes::D);
        unsafe { core::mem::ManuallyDrop::take(&mut self.payload.D) }
    }

    pub fn is_D(&self) -> bool {
        matches!(self.discriminant, discriminant_GlueTypes::D)
    }
}



impl GlueTypes {

    pub fn A(payload: InternalCommand) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::A,
            payload: union_GlueTypes {
                A: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn B(payload: InternalOutput) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::B,
            payload: union_GlueTypes {
                B: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn C(payload: InternalCommandErr) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::C,
            payload: union_GlueTypes {
                C: core::mem::ManuallyDrop::new(payload),
            }
        }
    }

    pub fn D(payload: InternalError) -> Self {
        Self {
            discriminant: discriminant_GlueTypes::D,
            payload: union_GlueTypes {
                D: core::mem::ManuallyDrop::new(payload),
            }
        }
    }
}

impl Drop for GlueTypes {
    fn drop(&mut self) {
        // Drop the payloads
        match self.discriminant() {
            discriminant_GlueTypes::A => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.A) },
            discriminant_GlueTypes::B => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.B) },
            discriminant_GlueTypes::C => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.C) },
            discriminant_GlueTypes::D => unsafe { core::mem::ManuallyDrop::drop(&mut self.payload.D) },
        }
    }
}



pub fn mainForHost() -> GlueTypes {
    extern "C" {
        fn roc__mainForHost_1_exposed_generic(_: *mut GlueTypes);
    }

    let mut ret = core::mem::MaybeUninit::uninit();

    unsafe {
        roc__mainForHost_1_exposed_generic(ret.as_mut_ptr(), );

        ret.assume_init()
    }
}